searchState.loadedDescShard("ltn", 0, "A partitioning of the interior of a neighbourhood based on …\nReplace the entire stack of states with this stack.\nThis destroys the current state, running the callback on …\nAn interval along a road’s length, with start &lt; end.\nDon’t do anything, keep the current state as the active …\nKeep the current state as the active one, but immediately …\nIf a state needs to pass data back to its parent, use …\nExecute a sequence of transitions in order.\nDestroy the current state, and resume from the previous one\nPush a new active state on the top of the stack.\nCall <code>State::recreate</code> on the current top of the stack\nReplace the current state with a new one. Equivalent to …\nIntersections which form the boundary of the …\nIntersections where this cell touches the boundary of the …\nRoads which are lie outside the <code>boundary_polygon</code> but could …\nLock the user into one fixed neighbourhood, and remove …\nReturns the argument unchanged.\nIntersections which are entirely inside the neighbourhood, …\nRoads which are either (a) entirely inside the …\nCalls <code>U::from(self)</code>.\nRoads which form part of the neighbourhood’s perimeter, …\nLoad a previously saved proposal with this name. Note this …\nMost roads are fully in one cell. Roads with modal filters …\nRoads which form part of the neighbourhood’s perimeter, …\nReplace the entire stack of states with this stack.\nThis destroys the current state, running the callback on …\nDon’t do anything, keep the current state as the active …\nKeep the current state as the active one, but immediately …\nIf a state needs to pass data back to its parent, use …\nExecute a sequence of transitions in order.\nDestroy the current state, and resume from the previous one\nPush a new active state on the top of the stack.\nCall <code>State::recreate</code> on the current top of the stack\nReplace the current state with a new one. Equivalent to …\nDraw unzoomed, but after the water/park areas layer, draw …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nBoth the top panel and the collapsible left sidebar.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nPanel won’t be initialized, must call <code>event</code> first\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIdentifies a single / unmerged block, which never changes\nTry adding one filter to every possible road, counting the …\nFind the road with the most shortcuts that can be closed …\nAn opaque ID, won’t be contiguous as we adjust boundaries\nPer cell, close all borders except for one. This doesn’t …\nFind one filter that splits a cell, maximizing the number …\nExperiments to make a neighbourhood be low-traffic by …\nEdit the map, adding modal filters and crossings that’re …\nTry adding one filter to every possible road, counting the …\nFind the road with the most shortcuts that can be closed …\nPer cell, close all borders except for one. This doesn’t …\nFind one filter that splits a cell, maximizing the number …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nEdit the map, adding modal filters and crossings that’re …\nReturns routes that start or stop crossing the given road. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIdentifies a single / unmerged block, which never changes\nAn opaque ID, won’t be contiguous as we adjust boundaries\nBlocks on the “frontier” are adjacent to the …\nOnly valid before the LTN tool has been activated this …\nWe want to add target_block to new_owner, but we can’t. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDraw a special cone of light when focused on this …\nNeeds to find an existing neighbourhood to take the block, …\nAdd all specified blocks to new_owner. <code>Ok(None)</code> is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAn attempt to standardise language around turn …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns a HashSet of all roads which are connected by …\nReturns all roads that are possible destinations from the …\nchecks that an Intersection ID is connected to a RoadID. …\nA partitioning of the interior of a neighbourhood based on …\nAn interval along a road’s length, with start &lt; end.\nIntersections which form the boundary of the …\nIntersections where this cell touches the boundary of the …\nRoads which are lie outside the <code>boundary_polygon</code> but could …\nRecalculates cells and shortcuts after a relevant edit\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIntersections which are entirely inside the neighbourhood, …\nRoads which are either (a) entirely inside the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA cell is disconnected if it’s not connected to a …\nRoads which form part of the neighbourhood’s perimeter, …\nMost roads are fully in one cell. Roads with modal filters …\nRoads which form part of the neighbourhood’s perimeter, …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nUpdate the panel, world, and neighbourhood (cells and …\nDon’t recreate the Neighbourhood\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates clickable objects for managing filters on roads …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nBuilds the geom representing the FocusTurns hull and …\nBuilds the geom representing each of the individual turn …\nBuilds the hover geom for showing turn restrictions when …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAdd a new trip while outside of this state and make it …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nDepending on the canvas zoom level, draws one of 2 things.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nBounds of the neighbourhood boundary polygon\nColors per cell, such that adjacent cells are colored …\nReturns a set of adjacent indices. The pairs are symmetric …\nDraw cells as areas with different colors. The colors are …\nDraw the boundary between cells as a thick outline. It’s …\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe grid only covers the boundary polygon of the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPartition a neighbourhood’s boundary polygon based on …\nRarely, this might be empty if the area is very small\nPer cell, convert all polygons to a <code>geo::MultiPolygon</code>. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCaptures all of the edits somebody makes to a map in the …\nCall before making any changes\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTry to load a proposal. If it fails, returns a popup …\nTODO All of this is in flux. Ultimately we should “just…\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.")